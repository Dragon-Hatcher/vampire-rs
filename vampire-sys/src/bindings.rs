/* automatically generated by rust-bindgen 0.72.1 */

pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of max_align_t"][::std::mem::size_of::<max_align_t>() - 32usize];
    ["Alignment of max_align_t"][::std::mem::align_of::<max_align_t>() - 16usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce1"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce1) - 0usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce2"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce2) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vampire_term_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vampire_literal_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vampire_formula_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vampire_unit_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vampire_clause_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vampire_problem_t {
    _unused: [u8; 0],
}
pub const vampire_proof_result_t_VAMPIRE_PROOF: vampire_proof_result_t = 0;
pub const vampire_proof_result_t_VAMPIRE_SATISFIABLE: vampire_proof_result_t = 1;
pub const vampire_proof_result_t_VAMPIRE_TIMEOUT: vampire_proof_result_t = 2;
pub const vampire_proof_result_t_VAMPIRE_MEMORY_LIMIT: vampire_proof_result_t = 3;
pub const vampire_proof_result_t_VAMPIRE_UNKNOWN: vampire_proof_result_t = 4;
pub const vampire_proof_result_t_VAMPIRE_INCOMPLETE: vampire_proof_result_t = 5;
#[doc = " Result of a proving attempt"]
pub type vampire_proof_result_t = ::std::os::raw::c_uint;
pub const vampire_input_type_t_VAMPIRE_AXIOM: vampire_input_type_t = 0;
pub const vampire_input_type_t_VAMPIRE_NEGATED_CONJECTURE: vampire_input_type_t = 1;
pub const vampire_input_type_t_VAMPIRE_CONJECTURE: vampire_input_type_t = 2;
#[doc = " Input type for units"]
pub type vampire_input_type_t = ::std::os::raw::c_uint;
pub const vampire_inference_rule_t_VAMPIRE_RULE_INPUT: vampire_inference_rule_t = 0;
pub const vampire_inference_rule_t_VAMPIRE_RULE_RESOLUTION: vampire_inference_rule_t = 1;
pub const vampire_inference_rule_t_VAMPIRE_RULE_FACTORING: vampire_inference_rule_t = 2;
pub const vampire_inference_rule_t_VAMPIRE_RULE_SUPERPOSITION: vampire_inference_rule_t = 3;
pub const vampire_inference_rule_t_VAMPIRE_RULE_EQUALITY_RESOLUTION: vampire_inference_rule_t = 4;
pub const vampire_inference_rule_t_VAMPIRE_RULE_EQUALITY_FACTORING: vampire_inference_rule_t = 5;
pub const vampire_inference_rule_t_VAMPIRE_RULE_CLAUSIFY: vampire_inference_rule_t = 6;
pub const vampire_inference_rule_t_VAMPIRE_RULE_OTHER: vampire_inference_rule_t = 99;
#[doc = " Inference rules (subset of commonly used rules)"]
pub type vampire_inference_rule_t = ::std::os::raw::c_uint;
#[doc = " A single step in a proof"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vampire_proof_step_t {
    pub id: ::std::os::raw::c_uint,
    pub rule: vampire_inference_rule_t,
    pub input_type: vampire_input_type_t,
    pub premise_ids: *mut ::std::os::raw::c_uint,
    pub premise_count: usize,
    pub unit: *mut vampire_unit_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vampire_proof_step_t"][::std::mem::size_of::<vampire_proof_step_t>() - 40usize];
    ["Alignment of vampire_proof_step_t"][::std::mem::align_of::<vampire_proof_step_t>() - 8usize];
    ["Offset of field: vampire_proof_step_t::id"]
        [::std::mem::offset_of!(vampire_proof_step_t, id) - 0usize];
    ["Offset of field: vampire_proof_step_t::rule"]
        [::std::mem::offset_of!(vampire_proof_step_t, rule) - 4usize];
    ["Offset of field: vampire_proof_step_t::input_type"]
        [::std::mem::offset_of!(vampire_proof_step_t, input_type) - 8usize];
    ["Offset of field: vampire_proof_step_t::premise_ids"]
        [::std::mem::offset_of!(vampire_proof_step_t, premise_ids) - 16usize];
    ["Offset of field: vampire_proof_step_t::premise_count"]
        [::std::mem::offset_of!(vampire_proof_step_t, premise_count) - 24usize];
    ["Offset of field: vampire_proof_step_t::unit"]
        [::std::mem::offset_of!(vampire_proof_step_t, unit) - 32usize];
};
unsafe extern "C" {
    #[doc = " Prepare for running another proof (light reset).\n Call this between independent proving attempts to reset\n the global ordering and other per-proof state.\n\n Note: This does NOT reset the signature - symbols accumulate\n between proofs. Use vampire_reset() for a full reset."]
    pub fn vampire_prepare_for_next_proof();
}
unsafe extern "C" {
    #[doc = " Fully reset the Vampire state for a fresh start.\n This resets all static caches, clears the signature, and\n reinitializes the environment. After calling this, the\n state is as if Vampire was just started.\n\n Call this between proofs if you want to reuse symbol names\n without conflicts, or to prevent memory growth from accumulated\n symbols and caches."]
    pub fn vampire_reset();
}
unsafe extern "C" {
    #[doc = " Set a time limit in seconds (0 = no limit)."]
    pub fn vampire_set_time_limit(seconds: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " Set a time limit in deciseconds (10 = 1 second, 0 = no limit)."]
    pub fn vampire_set_time_limit_deciseconds(deciseconds: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " Set a time limit in milliseconds (1000 = 1 second, 0 = no limit)."]
    pub fn vampire_set_time_limit_milliseconds(milliseconds: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " Enable or disable proof output."]
    pub fn vampire_set_show_proof(show: bool);
}
unsafe extern "C" {
    #[doc = " Set saturation algorithm.\n @param algorithm Name of algorithm (e.g., \"lrs\", \"discount\", \"otter\")"]
    pub fn vampire_set_saturation_algorithm(algorithm: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Register a function symbol with the given name and arity.\n For constants, use arity 0.\n @param name Symbol name (null-terminated string)\n @param arity Number of arguments\n @return functor index for use in term construction"]
    pub fn vampire_add_function(
        name: *const ::std::os::raw::c_char,
        arity: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Register a predicate symbol with the given name and arity.\n @param name Symbol name (null-terminated string)\n @param arity Number of arguments\n @return predicate index for use in literal construction"]
    pub fn vampire_add_predicate(
        name: *const ::std::os::raw::c_char,
        arity: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Create a variable term.\n @param index Variable index (0, 1, 2, ...)\n @return Term handle"]
    pub fn vampire_var(index: ::std::os::raw::c_uint) -> *mut vampire_term_t;
}
unsafe extern "C" {
    #[doc = " Create a constant term (0-arity function application).\n @param functor Function symbol index from vampire_add_function\n @return Term handle"]
    pub fn vampire_constant(functor: ::std::os::raw::c_uint) -> *mut vampire_term_t;
}
unsafe extern "C" {
    #[doc = " Create a function application term.\n @param functor Function symbol index from vampire_add_function\n @param args Array of argument terms\n @param arg_count Number of arguments\n @return Term handle"]
    pub fn vampire_term(
        functor: ::std::os::raw::c_uint,
        args: *mut *mut vampire_term_t,
        arg_count: usize,
    ) -> *mut vampire_term_t;
}
unsafe extern "C" {
    #[doc = " Create an equality literal (s = t or s != t).\n @param positive true for equality, false for disequality\n @param lhs Left-hand side term\n @param rhs Right-hand side term\n @return Literal handle"]
    pub fn vampire_eq(
        positive: bool,
        lhs: *mut vampire_term_t,
        rhs: *mut vampire_term_t,
    ) -> *mut vampire_literal_t;
}
unsafe extern "C" {
    #[doc = " Create a predicate literal.\n @param pred Predicate symbol index from vampire_add_predicate\n @param positive true for positive literal, false for negated\n @param args Array of argument terms\n @param arg_count Number of arguments\n @return Literal handle"]
    pub fn vampire_lit(
        pred: ::std::os::raw::c_uint,
        positive: bool,
        args: *mut *mut vampire_term_t,
        arg_count: usize,
    ) -> *mut vampire_literal_t;
}
unsafe extern "C" {
    #[doc = " Get the complementary (negated) literal.\n @param l The literal to negate\n @return Literal handle"]
    pub fn vampire_neg(l: *mut vampire_literal_t) -> *mut vampire_literal_t;
}
unsafe extern "C" {
    #[doc = " Create an atomic formula from a literal.\n @param l The literal\n @return Formula handle"]
    pub fn vampire_atom(l: *mut vampire_literal_t) -> *mut vampire_formula_t;
}
unsafe extern "C" {
    #[doc = " Create a negated formula (NOT f).\n @param f The formula to negate\n @return Formula handle"]
    pub fn vampire_not(f: *mut vampire_formula_t) -> *mut vampire_formula_t;
}
unsafe extern "C" {
    #[doc = " Create a conjunction (f1 AND f2 AND ...).\n @param formulas Array of formulas\n @param count Number of formulas\n @return Formula handle"]
    pub fn vampire_and(
        formulas: *mut *mut vampire_formula_t,
        count: usize,
    ) -> *mut vampire_formula_t;
}
unsafe extern "C" {
    #[doc = " Create a disjunction (f1 OR f2 OR ...).\n @param formulas Array of formulas\n @param count Number of formulas\n @return Formula handle"]
    pub fn vampire_or(
        formulas: *mut *mut vampire_formula_t,
        count: usize,
    ) -> *mut vampire_formula_t;
}
unsafe extern "C" {
    #[doc = " Create an implication (f1 => f2).\n @param lhs The antecedent\n @param rhs The consequent\n @return Formula handle"]
    pub fn vampire_imp(
        lhs: *mut vampire_formula_t,
        rhs: *mut vampire_formula_t,
    ) -> *mut vampire_formula_t;
}
unsafe extern "C" {
    #[doc = " Create an equivalence (f1 <=> f2).\n @param lhs Left-hand side\n @param rhs Right-hand side\n @return Formula handle"]
    pub fn vampire_iff(
        lhs: *mut vampire_formula_t,
        rhs: *mut vampire_formula_t,
    ) -> *mut vampire_formula_t;
}
unsafe extern "C" {
    #[doc = " Create a universally quantified formula (forall x. f).\n @param var_index The variable index to bind\n @param f The body formula\n @return Formula handle"]
    pub fn vampire_forall(
        var_index: ::std::os::raw::c_uint,
        f: *mut vampire_formula_t,
    ) -> *mut vampire_formula_t;
}
unsafe extern "C" {
    #[doc = " Create an existentially quantified formula (exists x. f).\n @param var_index The variable index to bind\n @param f The body formula\n @return Formula handle"]
    pub fn vampire_exists(
        var_index: ::std::os::raw::c_uint,
        f: *mut vampire_formula_t,
    ) -> *mut vampire_formula_t;
}
unsafe extern "C" {
    #[doc = " Create a true (tautology) formula.\n @return Formula handle"]
    pub fn vampire_true() -> *mut vampire_formula_t;
}
unsafe extern "C" {
    #[doc = " Create a false (contradiction) formula.\n @return Formula handle"]
    pub fn vampire_false() -> *mut vampire_formula_t;
}
unsafe extern "C" {
    #[doc = " Create an axiom formula unit.\n @param f The formula\n @return Unit handle"]
    pub fn vampire_axiom_formula(f: *mut vampire_formula_t) -> *mut vampire_unit_t;
}
unsafe extern "C" {
    #[doc = " Create a conjecture formula unit (to be proven).\n The formula is automatically negated for refutation-based proving.\n @param f The formula to prove\n @return Unit handle"]
    pub fn vampire_conjecture_formula(f: *mut vampire_formula_t) -> *mut vampire_unit_t;
}
unsafe extern "C" {
    #[doc = " Create an axiom clause (disjunction of literals).\n @param literals Array of literals\n @param count Number of literals\n @return Clause handle"]
    pub fn vampire_axiom_clause(
        literals: *mut *mut vampire_literal_t,
        count: usize,
    ) -> *mut vampire_clause_t;
}
unsafe extern "C" {
    #[doc = " Create a conjecture clause (to be refuted).\n @param literals Array of literals\n @param count Number of literals\n @return Clause handle"]
    pub fn vampire_conjecture_clause(
        literals: *mut *mut vampire_literal_t,
        count: usize,
    ) -> *mut vampire_clause_t;
}
unsafe extern "C" {
    #[doc = " Create a clause with specified input type.\n @param literals Array of literals\n @param count Number of literals\n @param input_type The type of input\n @return Clause handle"]
    pub fn vampire_clause(
        literals: *mut *mut vampire_literal_t,
        count: usize,
        input_type: vampire_input_type_t,
    ) -> *mut vampire_clause_t;
}
unsafe extern "C" {
    #[doc = " Create a problem from an array of clauses.\n @param clauses Array of clause handles\n @param count Number of clauses\n @return Problem handle"]
    pub fn vampire_problem_from_clauses(
        clauses: *mut *mut vampire_clause_t,
        count: usize,
    ) -> *mut vampire_problem_t;
}
unsafe extern "C" {
    #[doc = " Create a problem from an array of units (clauses or formulas).\n Formulas will be clausified during preprocessing.\n @param units Array of unit handles\n @param count Number of units\n @return Problem handle"]
    pub fn vampire_problem_from_units(
        units: *mut *mut vampire_unit_t,
        count: usize,
    ) -> *mut vampire_problem_t;
}
unsafe extern "C" {
    #[doc = " Run the prover on a problem.\n @param problem The problem to solve\n @return The proof result"]
    pub fn vampire_prove(problem: *mut vampire_problem_t) -> vampire_proof_result_t;
}
unsafe extern "C" {
    #[doc = " Get the refutation (proof) after a successful vampire_prove() call.\n @return The empty clause with inference chain, or NULL if no proof"]
    pub fn vampire_get_refutation() -> *mut vampire_unit_t;
}
unsafe extern "C" {
    #[doc = " Print the proof to stdout.\n @param refutation The refutation from vampire_get_refutation()"]
    pub fn vampire_print_proof(refutation: *mut vampire_unit_t);
}
unsafe extern "C" {
    #[doc = " Print the proof to a file.\n @param filename Path to output file (null-terminated string)\n @param refutation The refutation from vampire_get_refutation()\n @return 0 on success, -1 on error"]
    pub fn vampire_print_proof_to_file(
        filename: *const ::std::os::raw::c_char,
        refutation: *mut vampire_unit_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Extract the proof as a sequence of steps.\n Steps are returned in topological order (premises before conclusions).\n The last step is the empty clause (refutation).\n\n @param refutation The refutation from vampire_get_refutation()\n @param out_steps Pointer to receive the array of proof steps\n @param out_count Pointer to receive the number of steps\n @return 0 on success, -1 on error\n\n Note: The caller must free the returned array and each step's premise_ids array."]
    pub fn vampire_extract_proof(
        refutation: *mut vampire_unit_t,
        out_steps: *mut *mut vampire_proof_step_t,
        out_count: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Free the proof steps array returned by vampire_extract_proof().\n @param steps The array to free\n @param count Number of steps"]
    pub fn vampire_free_proof_steps(steps: *mut vampire_proof_step_t, count: usize);
}
unsafe extern "C" {
    #[doc = " Get the literals of a clause as an array.\n @param clause The clause\n @param out_literals Pointer to receive the array of literals\n @param out_count Pointer to receive the number of literals\n @return 0 on success, -1 on error\n\n Note: The caller must free the returned array."]
    pub fn vampire_get_literals(
        clause: *mut vampire_clause_t,
        out_literals: *mut *mut *mut vampire_literal_t,
        out_count: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Free the literals array returned by vampire_get_literals().\n @param literals The array to free"]
    pub fn vampire_free_literals(literals: *mut *mut vampire_literal_t);
}
unsafe extern "C" {
    #[doc = " Get the clause from a unit (if the unit is a clause).\n @param unit The unit\n @return Clause handle, or NULL if unit is not a clause"]
    pub fn vampire_unit_as_clause(unit: *mut vampire_unit_t) -> *mut vampire_clause_t;
}
unsafe extern "C" {
    #[doc = " Check if a clause is empty (represents false).\n @param clause The clause\n @return true if empty, false otherwise"]
    pub fn vampire_clause_is_empty(clause: *mut vampire_clause_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Convert a term to a string representation.\n @param term The term\n @return Allocated string (must be freed with vampire_free_string), or NULL on error"]
    pub fn vampire_term_to_string(term: *mut vampire_term_t) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Convert a literal to a string representation.\n @param literal The literal\n @return Allocated string (must be freed with vampire_free_string), or NULL on error"]
    pub fn vampire_literal_to_string(
        literal: *mut vampire_literal_t,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Convert a clause to a string representation.\n @param clause The clause\n @return Allocated string (must be freed with vampire_free_string), or NULL on error"]
    pub fn vampire_clause_to_string(clause: *mut vampire_clause_t) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Convert a formula to a string representation.\n @param formula The formula\n @return Allocated string (must be freed with vampire_free_string), or NULL on error"]
    pub fn vampire_formula_to_string(
        formula: *mut vampire_formula_t,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Free a string allocated by vampire_*_to_string functions.\n @param str The string to free"]
    pub fn vampire_free_string(str: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Get the name of an inference rule.\n @param rule The inference rule\n @return String name (static, do not free)"]
    pub fn vampire_rule_name(rule: vampire_inference_rule_t) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the name of an input type.\n @param input_type The input type\n @return String name (static, do not free)"]
    pub fn vampire_input_type_name(
        input_type: vampire_input_type_t,
    ) -> *const ::std::os::raw::c_char;
}
